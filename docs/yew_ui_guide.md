# Гайд для студентов: компоненты и интерфейс в Yew (учебный проект)

Документ объясняет, **как устроены компоненты в Yew** и **как собирать UI**
в текущем учебном проекте. Текст рассчитан на начинающих и написан простым
техническим языком.

## 1. Контекст проекта

В проекте используется **Yew** — веб‑фреймворк на Rust. UI компилируется
в WebAssembly и работает в браузере. Архитектура проекта следует учебному
подходу DDD: UI‑слой обращается к сценариям использования (use‑cases), которые
инкапсулируют работу с API.

Полезные опорные документы:

- `docs/stack_guide.md` — обзор стека;
- `docs/ui_ux_requirements.md` — требования к интерфейсу;
- `docs/api_contract.md` — контракт API;
- `docs/build_and_run.md` — запуск и сборка UI.

## 2. Что такое компонент в Yew

**Компонент** — это функция или структура, которая:

1. **получает входные параметры** (props);
2. **хранит состояние** (state) при необходимости;
3. **возвращает разметку** (`Html`), которая отображается в браузере.

В учебном проекте используются **функциональные компоненты**.

### Простейший пример

```rust
use yew::prelude::*;

#[function_component(Hello)]
pub fn hello() -> Html {
    html! { <p>{"Привет, Yew!"}</p> }
}
```

## 3. Где находится корневой компонент

Главный компонент приложения — `App`, он расположен в `src/app.rs`.
Точка входа (`src/main.rs`) только монтирует `App` в HTML‑элемент `#app`.

Порядок работы:

1. `main.rs` запускает Yew.
2. `App` строит интерфейс.
3. Внутри `App` можно создавать и подключать дочерние компоненты.

## 4. Разметка в Yew: макрос `html!`

Yew использует макрос `html!`, который похож на HTML, но является Rust‑кодом.

Пример:

```rust
html! {
    <section class="panel">
        <h2>{"Заголовок"}</h2>
        <p>{"Текст"}</p>
    </section>
}
```

Правила:

- строки в фигурных скобках: `{"текст"}`;
- значения из переменных: `{value}`;
- атрибуты задаются как в HTML: `class="..."`, `id="..."`.

## 5. Props (входные параметры)

**Props** — это данные, которые родительский компонент передаёт дочернему.

### Пример props

```rust
#[derive(Properties, PartialEq)]
pub struct CardProps {
    pub title: String,
    pub text: String,
}

#[function_component(Card)]
pub fn card(props: &CardProps) -> Html {
    html! {
        <div class="card">
            <h3>{props.title.clone()}</h3>
            <p>{props.text.clone()}</p>
        </div>
    }
}
```

**Почему нужен `PartialEq`:**
Yew использует сравнение props для оптимизации перерисовок.

## 6. State (состояние компонента)

**State** — это изменяемые данные внутри компонента.
Для этого используется хук `use_state`.

### Пример

```rust
let counter = use_state(|| 0);

let on_inc = {
    let counter = counter.clone();
    Callback::from(move |_| counter.set(*counter + 1))
};

html! {
    <div>
        <p>{format!("Счётчик: {}", *counter)}</p>
        <button onclick={on_inc}>{"+"}</button>
    </div>
}
```

Правило: **состояние меняется только через `.set(...)`**.

## 7. Эффекты (use_effect / use_effect_with)

Эффекты нужны, чтобы выполнять действия при изменении состояния,
например запросы к API.

### Пример с зависимостью

```rust
use_effect_with((*api_url).clone(), move |_| {
    // выполнить запрос
    || () // функция очистки
});
```

Здесь эффект будет запускаться **когда меняется `api_url`**.

## 8. Обработка событий

Чаще всего используются события ввода и клика.

### Пример для `textarea`

```rust
let on_input = {
    let value = value.clone();
    Callback::from(move |event: InputEvent| {
        let input: HtmlTextAreaElement = event.target_unchecked_into();
        value.set(input.value());
    })
};
```

### Пример для кнопки

```rust
let on_click = Callback::from(move |_| {
    // действие
});
```

## 9. Асинхронность и запросы к API

В браузере нельзя блокировать поток. Поэтому асинхронные операции запускаются
через `spawn_local`.

Пример шаблона из проекта:

```rust
spawn_local(async move {
    // 1) перевести состояние в Loading
    // 2) вызвать use‑case
    // 3) записать результат или ошибку
});
```

В проекте **UI не обращается к API напрямую**. Вместо этого используются
use‑cases:

- `AskQuestionUseCase` — отправка вопроса;
- `CheckHealthUseCase` — проверка состояния API.

Это облегчает тестирование и сохраняет архитектуру.

## 10. Шаблон «Loading / Error / Ready»

В проекте используется единый подход для отображения состояний:

- `Idle` — ничего не происходит;
- `Loading` — запрос выполняется;
- `Ready` — есть результат;
- `Error` — произошла ошибка.

Такой подход делает UI предсказуемым и понятным для пользователя.

## 11. Разделение на компоненты

Когда экран становится большим, его стоит делить на компоненты:

- главный компонент хранит состояние и логику;
- дочерние компоненты получают данные через props и отвечают за разметку.

### Пример структуры

```
src/
  app.rs            # главный компонент
  ui/
    answer_card.rs  # визуальный компонент
    status_panel.rs # визуальный компонент
```

**Практическое правило:** если внутри `html!` более ~80–100 строк, стоит
выносить часть UI в отдельный компонент.

## 12. Стили и классы

В проекте используется обычный CSS (`styles.css`).

Правило: **классы должны быть осмысленными и единообразными**.
Например, в текущем интерфейсе используются:

- `app__header`, `app__main`;
- `panel`, `panel__header`;
- `button`, `button--ghost`.

## 13. Доступность (минимум)

UI должен быть доступным:

- использовать `<label>` для полей ввода;
- указывать понятные подписи;
- не полагаться только на цвет (например, добавить текстовое описание ошибки);
- использовать `aria-live` для динамических сообщений.

Подробности см. `docs/ui_ux_requirements.md`.

## 14. Пошаговый алгоритм создания компонента

1. Определить, какие данные нужны компоненту.
2. Если данные приходят извне — создать `Props`.
3. Написать `#[function_component]`.
4. Добавить разметку через `html!`.
5. Подключить обработчики событий.
6. Подключить компонент в `App`.
7. Проверить поведение в UI.

## 15. Типичные ошибки

1. **Изменение state без `.set(...)`** — UI не обновляется.
2. **Долгая операция без `spawn_local`** — интерфейс «замерзает».
3. **Отсутствие `PartialEq` в Props** — лишние перерисовки.
4. **Смешивание логики и разметки** — сложность поддержки.
5. **Игнорирование CORS** — UI не может обращаться к API (см. `docs/common_issues.md`).

## 16. Мини‑чек‑лист перед сдачей

- UI запускается через `trunk serve`.
- Запросы к API проходят без ошибок CORS.
- Кнопки блокируются при `Loading`.
- Ошибки отображаются текстом.
- Код читабелен и разделён на понятные части.

---

Этот гайд можно использовать как основу для лабораторных работ,
домашних заданий и самостоятельных экспериментов с UI на Rust.
