# Учебный гайд по технологическому стеку проекта

Документ описывает все основные фреймворки и библиотеки, которые
используются в учебном проекте. Текст рассчитан на студентов без опыта и
объясняет термины, роль каждого инструмента и типовые практики.

## 0. Карта стека (коротко)

- **Rust** — язык программирования.
- **Cargo** — сборка и зависимости.
- **Yew** — UI‑фреймворк.
- **Trunk** — сборка и запуск UI.
- **WebAssembly (WASM)** — формат, в котором код работает в браузере.
- **wasm‑bindgen / web‑sys / js‑sys** — мост между Rust и Web API.
- **gloo / gloo‑net / gloo‑storage** — удобные обёртки над браузерными API.
- **serde / serde_json** — сериализация и JSON.
- **async‑trait / thiserror** — удобство для асинхронности и ошибок.
- **wasm‑bindgen‑futures** — запуск асинхронных задач в браузере.

Ниже — подробный разбор каждого пункта.

## 1. Rust и Cargo

### 1.1. Rust

Rust — системный язык программирования с упором на безопасность памяти и
производительность. В рамках курса Rust используется для написания
клиентского кода, который затем компилируется в WebAssembly.

### 1.2. Cargo

**Cargo** — стандартный менеджер пакетов и сборки в Rust. Он:
- скачивает зависимости;
- компилирует проект;
- запускает приложение.

Cargo также задаёт структуру проекта: файл `Cargo.toml` хранит список
зависимостей и метаданные.

**Практика:** все зависимости добавляются в `Cargo.toml`, а сборка и
запуск выполняются командами `cargo build` и `cargo run`.

## 2. WebAssembly (WASM)

**WebAssembly** — формат исполняемого кода, который поддерживают
современные браузеры. Он работает рядом с JavaScript и позволяет запускать
код на высокой скорости. WebAssembly задуман как целевая платформа для
компиляции языков (в том числе Rust) в браузер.

**Практика:** Rust‑код компилируется в WASM, затем браузер загружает этот
модуль и исполняет его.

## 3. Yew (UI‑фреймворк)

### 3.1. Что такое Yew

**Yew** — фреймворк для построения UI на Rust. Он использует компонентный
подход: интерфейс строится из отдельных компонентов. В Yew основным
рекомендуемым стилем для новичков являются **функциональные компоненты**.

### 3.2. Компоненты

Компоненты в Yew:
- принимают параметры (props),
- могут хранить состояние,
- возвращают разметку (`Html`), которая отображается в браузере.

Функциональный компонент создаётся как обычная функция с атрибутом
`#[function_component]`.

### 3.3. Хуки

**Хуки** — функции, которые позволяют хранить состояние и выполнять
побочные действия внутри функционального компонента.

Примеры стандартных хуков: `use_state`, `use_effect`, `use_memo`.

### 3.4. Обновления в Yew 0.22

В релизе Yew 0.22 атрибут `#[function_component]` получил более короткий
вариант `#[component]`. Старое имя пока поддерживается, но считается
устаревающим.

**Практика:** в учебном коде допустимо использовать `#[function_component]`,
но полезно знать об обновлении.

## 4. Trunk (сборка и запуск UI)

**Trunk** — инструмент, который собирает Rust‑UI в WASM и запускает
локальный сервер разработки. Основные команды:

- `trunk build` — сборка WASM и статических файлов;
- `trunk watch` — сборка с наблюдением за файлами;
- `trunk serve` — `watch` + встроенный веб‑сервер.

**Практика:** для разработки используется `trunk serve`, для финальной
сборки — `trunk build`.

## 5. wasm‑bindgen и экосистема Web API

### 5.1. wasm‑bindgen

`wasm‑bindgen` — библиотека и инструмент, которые связывают Rust и
JavaScript. Он обеспечивает удобный обмен строками, объектами и функциями
между WASM и JS.

### 5.2. web‑sys

`web‑sys` даёт низкоуровневые привязки ко всем Web API. Он
генерируется из WebIDL и требует включать нужные API через Cargo‑фичи.

### 5.3. js‑sys

`js‑sys` предоставляет привязки к стандартным объектам JavaScript,
например `Date`, `Array`, `Function`. Эти объекты определены стандартом
ECMAScript и доступны везде.

### 5.4. wasm‑bindgen‑futures

Эта библиотека связывает Rust‑`Future` и JavaScript‑`Promise`. Она
предоставляет:
- `JsFuture` для работы с `Promise`,
- `future_to_promise`,
- `spawn_local` для запуска async‑задач в браузере.

**Практика:** в UI часто используются `spawn_local`, чтобы выполнить
асинхронный запрос без блокировки интерфейса.

## 6. Gloo и его модули

### 6.1. Gloo (общая библиотека)

**Gloo** — модульный набор инструментов для Rust + WASM. В нём есть
модули для работы с консолью, событиями, таймерами, сетью, хранилищем и т.д.

### 6.2. gloo‑net

`gloo‑net` — HTTP‑библиотека для WASM, которая оборачивает браузерный
`fetch` и `WebSocket`.

**Практика:** в учебном UI запросы к API выполняются через `gloo‑net`.

### 6.3. gloo‑storage

`gloo‑storage` — обёртка над Web Storage API (`localStorage` и
`sessionStorage`). Данные сохраняются в JSON с использованием `serde`.

**Практика:** в UI базовый URL API сохраняется в `localStorage`.

## 7. serde и serde_json

### 7.1. serde

**Serde** — библиотека для сериализации и десериализации структур данных.
Она позволяет автоматически получать JSON из Rust‑структур и обратно.

### 7.2. serde_json

`serde_json` — реализация JSON‑формата для Serde. JSON — текстовый формат
«ключ‑значение», широко используемый в веб‑API.

**Практика:** все данные между UI и API передаются в JSON.

## 8. async‑trait

Асинхронные методы в трейтах имеют ограничения, если требуется `dyn Trait`.
Библиотека `async‑trait` предоставляет атрибут, который делает такие
методы удобными и совместимыми.

**Практика:** в проекте через `async‑trait` определяются абстракции
(например, интерфейсы для сетевых запросов).

## 9. thiserror

`thiserror` — удобный derive‑макрос для создания собственных типов ошибок,
которые реализуют стандартный `std::error::Error`.

**Практика:** использовать `thiserror` проще и читабельнее, чем писать
реализацию ошибок вручную.

## 10. Источники и дополнительное чтение

Ниже приведены официальные источники, на которые опирается этот гайд.
Их полезно использовать как базовую точку отсчёта и для проверки деталей.

### 10.1. Официальные документации (основные)

- Rust (The Rust Programming Language): https://doc.rust-lang.org/book/
- Cargo (The Cargo Book): https://doc.rust-lang.org/cargo/
- Yew (официальный учебный раздел): https://yew.rs/docs/next/tutorial/
- Yew (API и примеры): https://docs.rs/crate/yew/latest
- Yew 0.22 (официальные заметки о релизе): https://yew.rs/blog/2024-11-22-yew-0-22/
- Trunk: https://trunkrs.dev/guide/getting-started/pre-reqs/
- wasm-bindgen (guide): https://rustwasm.github.io/docs/wasm-bindgen/
- wasm-bindgen-futures (API): https://wasm-bindgen.github.io/wasm-bindgen/api/wasm_bindgen_futures/
- web-sys (API): https://docs.rs/web-sys
- js-sys (API): https://docs.rs/crate/js-sys/0.3.21
- gloo (официальный сайт и обзор модулей): https://gloo-rs.web.app/
- gloo-net (API): https://docs.rs/gloo-net
- gloo-storage (API): https://docs.rs/gloo-storage
- Serde (официальный сайт): https://serde.rs/
- serde_json (API): https://docs.rs/serde_json
- async-trait (API): https://docs.rs/async-trait
- thiserror (API): https://docs.rs/thiserror

### 10.2. Обзорные статьи и учебные материалы высокого качества

- WebAssembly Concepts (MDN): https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts

## 11. Как связаны все части стека

1. UI пишется на Rust с помощью Yew.
2. Код компилируется в WASM через Trunk.
3. WASM исполняется в браузере и обращается к Web API через wasm‑bindgen,
   web‑sys и js‑sys.
4. Сетевые запросы выполняются через gloo‑net.
5. Настройки сохраняются через gloo‑storage.
6. JSON‑данные обрабатываются Serde и serde_json.
7. Асинхронные операции и ошибки оформляются async‑trait и thiserror.

Такая связка обеспечивает понятную архитектуру и даёт студентам полный
пример современного Rust‑UI проекта.

## 12. Процесс работы (служебно)

В репозитории зафиксирован формальный порядок работы с задачами и git:

- `agents-issue-workflow.cncf.yaml` — CNCF Serverless Workflow для агентских правил.

Правила для коммитов:
- первая строка коммита совпадает с заголовком issue;
- тело коммита совпадает с описанием issue;
- после описания добавляется список изменённых файлов.

Важно: `bd sync` коммитит только `.beads/issues.jsonl` и не коммитит
изменения проекта, поэтому проектный коммит выполняется вручную.

Документы полезны для контроля дисциплины работы, но не обязательны для
выполнения лабораторных заданий.
