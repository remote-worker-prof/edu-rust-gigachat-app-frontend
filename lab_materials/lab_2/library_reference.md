# Справочные материалы по зависимостям проекта (UI)

## 1. Введение

Настоящий документ содержит краткое описание основных библиотек (крейтов),
используемых в учебном UI‑проекте `rust-gigachat-webapp`. Цель справочника —
дать студентам стартовую точку для чтения документации и понимания роли
каждой технологии.

Структура справочника:

- назначение библиотеки;
- краткое описание;
- полезные ссылки;
- практические замечания и типичные ошибки.

## 2. Основные зависимости

### 2.1. Yew

**Назначение:** UI‑фреймворк для создания веб‑интерфейсов на Rust.

**Описание:** Yew предоставляет компонентную модель, состояние, обработку
событий и рендеринг в DOM. В проекте используются функциональные компоненты.

| Ресурс | Ссылка |
|---|---|
| Официальная документация | https://yew.rs/docs/ |
| Учебный tutorial | https://yew.rs/docs/next/tutorial/ |
| API на docs.rs | https://docs.rs/yew |
| Заметки о релизе 0.22 | https://yew.rs/blog/2024-11-22-yew-0-22/ |

**⚠️ Важно знать:**

1. **Функциональные компоненты** объявляются через `#[function_component]` или
   `#[component]` (начиная с Yew 0.22).
2. **Props должны реализовывать `PartialEq`**, иначе Yew не сможет корректно
   оптимизировать перерисовку.
3. **Состояние меняется только через `.set(...)`**. Прямое изменение значения
   не вызовет обновления интерфейса.
4. **Обработчики событий** получают данные из `event.target_unchecked_into()` —
   это безопасно, если известно, какой именно элемент вызвал событие.
5. **Рендеринг выполняется при изменении state или props**. Если UI не
   обновился — значит состояние не было обновлено корректно.

**Мини‑пример компонента:**

```rust
#[function_component(Hello)]
pub fn hello() -> Html {
    html! { <p>{"Привет, Yew!"}</p> }
}
```

**Пример props:**

```rust
#[derive(Properties, PartialEq)]
pub struct CardProps {
    pub title: String,
}

#[function_component(Card)]
pub fn card(props: &CardProps) -> Html {
    html! { <h3>{props.title.clone()}</h3> }
}
```

**Типичные ошибки:**

- забыто `PartialEq` в props;
- попытка изменить state без `.set(...)`;
- слишком крупный компонент без разделения на под‑компоненты;
- отсутствие `key` при отрисовке списков.

### 2.2. Trunk

**Назначение:** сборка и запуск UI‑проекта (WASM + статические ресурсы).

**Описание:** Trunk компилирует Rust в WebAssembly, собирает HTML/CSS, запускает
локальный dev‑сервер.

| Ресурс | Ссылка |
|---|---|
| Официальный гайд | https://trunkrs.dev/ |

**⚠️ Важно знать:**

1. Для сборки требуется `wasm32-unknown-unknown`.
2. Для локального запуска используется `trunk serve`.
3. В учебной среде требуется `NO_COLOR=true` (известная особенность).
4. Trunk может работать как прокси (полезно для CORS‑сценариев).

**Мини‑команды:**

```bash
NO_COLOR=true trunk build
NO_COLOR=true trunk serve --address 127.0.0.1 --port 8080
```

**Практическое замечание:**

- `index.html` в корне проекта определяет, что именно будет загружено в
  браузере. Trunk автоматически подставляет WASM‑bundle.

### 2.3. WebAssembly и wasm‑bindgen

**Назначение:** запуск Rust‑кода в браузере и связь с JavaScript.

**Описание:** WebAssembly — формат исполняемого кода, а `wasm‑bindgen` обеспечивает
конвертацию типов и вызов Web API.

| Ресурс | Ссылка |
|---|---|
| Rust‑WASM Book | https://rustwasm.github.io/docs/ |
| wasm‑bindgen guide | https://rustwasm.github.io/docs/wasm-bindgen/ |
| MDN WebAssembly | https://developer.mozilla.org/docs/WebAssembly |

**⚠️ Важно знать:**

1. WASM не может напрямую обращаться к DOM без привязок.
2. `wasm‑bindgen` обеспечивает взаимодействие Rust ↔ JS.
3. Ошибки взаимодействия с JS часто проявляются как runtime‑ошибки в браузере.

### 2.4. web‑sys и js‑sys

**Назначение:** доступ к Web API и объектам JavaScript.

**Описание:** `web‑sys` содержит привязки к браузерным API, `js‑sys` — к
стандартным объектам JavaScript.

| Ресурс | Ссылка |
|---|---|
| web‑sys | https://docs.rs/web-sys |
| js‑sys | https://docs.rs/js-sys |

**⚠️ Важно знать:**

1. `web‑sys` требует явного включения API через Cargo‑фичи.
2. В учебном проекте прямое использование редкое — чаще через `gloo`.

### 2.5. gloo (gloo‑net, gloo‑storage)

**Назначение:** удобные обёртки над браузерными API.

**Описание:** `gloo‑net` упрощает HTTP‑запросы, `gloo‑storage` — работу с
`localStorage`.

| Ресурс | Ссылка |
|---|---|
| gloo | https://gloo-rs.web.app/ |
| gloo‑net | https://docs.rs/gloo-net |
| gloo‑storage | https://docs.rs/gloo-storage |

**⚠️ Важно знать:**

1. `gloo‑net` работает поверх `fetch` и наследует его ограничения (CORS).
2. `gloo‑storage` хранит данные в JSON через Serde.
3. При чтении/записи в `localStorage` возможны ошибки сериализации.

**Мини‑пример запроса:**

```rust
let response = Request::get(url).send().await?;
let text = response.text().await?;
```

### 2.6. Serde и serde_json

**Назначение:** сериализация/десериализация данных в JSON.

**Описание:** Serde позволяет автоматически преобразовывать структуры Rust в
JSON и обратно. В UI это используется при отправке запросов и чтении ответов.

| Ресурс | Ссылка |
|---|---|
| Serde | https://serde.rs/ |
| serde_json | https://docs.rs/serde_json |

**⚠️ Важно знать:**

1. Несовпадение структуры JSON и Rust‑модели приводит к `InvalidPayload`.
2. Поля в JSON чувствительны к названию. Несовпадение имён вызовет ошибку.
3. Можно использовать `#[serde(rename = "...")]` для согласования имён.

### 2.7. async‑trait и thiserror

**Назначение:** удобное описание асинхронных трейтов и ошибок.

**Описание:** `async‑trait` позволяет писать async‑методы в трейтах, а
`thiserror` упрощает объявление ошибок.

| Ресурс | Ссылка |
|---|---|
| async‑trait | https://docs.rs/async-trait |
| thiserror | https://docs.rs/thiserror |

**⚠️ Важно знать:**

1. Без `async‑trait` нельзя описывать async‑методы в трейтах с `dyn`.
2. `thiserror` делает ошибки более читаемыми и удобными для пользователя.

### 2.8. wasm‑bindgen‑futures

**Назначение:** запуск асинхронных задач в браузере.

**Описание:** связывает `Future` Rust и `Promise` JavaScript, предоставляет
`spawn_local`.

| Ресурс | Ссылка |
|---|---|
| wasm‑bindgen‑futures | https://wasm-bindgen.github.io/wasm-bindgen/api/wasm_bindgen_futures/ |

**⚠️ Важно знать:**

1. В браузере нет многопоточности как на сервере — используется `spawn_local`.
2. Долгие операции должны выполняться асинхронно, иначе UI «замёрзнет».

### 2.9. gloo‑console (опционально)

**Назначение:** удобный вывод сообщений в консоль браузера.

**Описание:** позволяет логировать значения для отладки.

| Ресурс | Ссылка |
|---|---|
| gloo‑console | https://docs.rs/gloo-console |

**⚠️ Важно знать:**

1. В учебных работах логирование полезно для отладки событий и запросов.
2. После отладки лишние логи следует удалять.

### 2.10. web‑sys (DOM и элементы формы)

**Назначение:** доступ к DOM‑элементам, полям ввода, событиям.

**Описание:** через `web‑sys` можно работать с `HtmlInputElement`,
`HtmlTextAreaElement` и другими элементами формы.

| Ресурс | Ссылка |
|---|---|
| HtmlInputElement | https://docs.rs/web-sys/latest/web_sys/struct.HtmlInputElement.html |
| HtmlTextAreaElement | https://docs.rs/web-sys/latest/web_sys/struct.HtmlTextAreaElement.html |

**⚠️ Важно знать:**

1. В UI‑коде элементы извлекаются из события: `event.target_unchecked_into()`.
2. Ошибка в типе элемента приведёт к panic в браузере.

### 2.11. Yew hooks (use_state, use_effect, use_memo)

**Назначение:** хранение состояния и выполнение побочных действий.

**Описание:** хуки позволяют функциональному компоненту иметь состояние и
реагировать на его изменения.

| Ресурс | Ссылка |
|---|---|
| Hooks (Yew docs) | https://yew.rs/docs/next/concepts/function-components/hooks |

**⚠️ Важно знать:**

1. `use_state` хранит значение и возвращает handle, который нужно обновлять через `.set(...)`.
2. `use_effect_with` выполняется при изменении зависимости.
3. `use_memo` кэширует вычисление при тех же входных данных.

### 2.12. html! и шаблоны разметки

**Назначение:** описание интерфейса внутри Rust‑кода.

**Описание:** макрос `html!` позволяет писать разметку в стиле HTML с подстановкой
значений Rust.

| Ресурс | Ссылка |
|---|---|
| Yew html! macro | https://yew.rs/docs/next/concepts/html |

**⚠️ Важно знать:**

1. Текстовые значения должны быть в `{\"...\"}` или `{var}`.
2. Для списков рекомендуется использовать `key`.
3. Условный рендеринг делается через `if` или `match`.

## 3. Практические замечания по проекту

1. UI не обращается к API напрямую — используются use‑cases.
2. Сценарии `AskQuestionUseCase` и `CheckHealthUseCase` отделяют UI от сети.
3. Ошибки отображаются через общий шаблон `Loading / Error / Ready`.
4. Базовый URL можно менять в UI и сохранять в `localStorage`.
5. При смене URL автоматически запускается проверка состояния.

## 4. Типовые проблемы и их причины

- **CORS** — UI и API на разных портах, сервер не разрешил запросы.
- **InvalidPayload** — ответ API не соответствует ожидаемой структуре.
- **Failed to fetch** — проблема сети, CORS или неверный URL.

Подробные решения см. в `docs/common_issues.md`.

## 5. Дополнительные источники проекта

- `docs/stack_guide.md` — полный обзор стека;
- `docs/yew_ui_guide.md` — подробный учебный гайд по UI;
- `docs/common_issues.md` — частые ошибки (включая CORS).
